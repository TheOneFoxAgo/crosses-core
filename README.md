# crosses-core

Полное описание игры ищите в книге **"Логика или фортуна"**. Ядро игры существует, чтобы позволить интересующимся заменять главные алгоритмы и структуры данных, не трогая игровую логику.

---

# Использование:

1. Пользователь реализует структуру игрового поля, а ядро предоставляет ему 2 игровые функции: `make_move()` и `cancel_move()`, а также 1 служебную: `init()`.
	- `make_move()` - сделать ход
	- `cancel_move()` - отменить ход
	- `init()` - проинициализировать поле: расставить все нужные флаги и активность. **ВНИМАНИЕ!** Функция `init()` ожидает, что все клетки изначально имеют "нулевую" активность. То же относится ко всем флагам. Они все `false`.
2. Пользователь инициализирует поле (С помощью `init()`).
3. Пользователь инициализирует `PlayerManager` (Специальная структура для организации порядка ходов)
4. Пользователь использует эти структуры в своей реализации игры (Методы `make_move()` и `cancel_move()`)
5. ???
6. Profit!!!

# Ключевые контракты

Чтобы можно было предоставить функции `make_move()` и `cancel_move()` надо удовлетворить следующие контракты для поля и его клетки.

## Клетка

Клетка - единица поля. Имеет 3+1 ключевых состояния: пуста, содержит крестик, закрашена, является границей.

### Пустая клетка

Должна иметь следующие свойства:
1. Тип
2. Активность (Может ли игрок взаимодействовать с клеткой. Для каждого игрока, должна храниться своя, индивидуальная активность. Рекомендую использовать `bitfield` или что-то подобное)

### Крестик

1. Тип
2. Цвет
2. Активность (Естественно, для каждого игрока своя. Поскольку игрок не может взаимодействовать с крестиком своего цвета, ядро не читает активность крестика для своего же цвета. Можете её использовать для своих нужд, например для следующего пункта.)
3. Флаг "Якоря" (`bool`. Используется для для уменьшения перепроверок.)

### Закрашенная клетка

1. Тип
2. Цвет
3. Предыдущий цвет (Это нужно в для отмены ходов)
4. Флаг "Близости" (`bool`. Находится ли клетка вблизи якоря. Используется для уменьшения перепроверок.)
5. Флаг "Жизни" (`bool`. Соприкасается ли цепочка закрашенных клеток с крестиком своего цвета)

### Граница

1. Тип. Ну и всё на этом.

## Поле

Само игровое поле должно реализовывать следующие методы:
1. Получение клетки по индексу.
2. Получение всех индексов клеток вокруг.
3. Обход цепочки закрашенных клеток. На вход этому методу подаются: начальная клетка обхода (Гарантированно закрашенная) и стратегия. Стратегией является обычная лямбда вида `FnMut(board, index) -> ControlFlow`. На возвращаемое значение нужно соответствующим образом реагировать.


