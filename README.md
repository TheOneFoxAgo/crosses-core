# crosses-core

Полное описание игры ищите в книге **"Логика или фортуна"**. Ядро игры существует, чтобы позволить интересующимся заменять главные алгоритмы и структуры данных, не трогая игровую логику.

# Использование:

1. Пользователь реализует структуру игрового поля, а ядро предоставляет ему 2 игровые функции: `make_move()` и `cancel_move()`.
	- `make_move()` - сделать ход
	- `cancel_move()` - отменить ход
2. Пользователь инициализирует поле (Для этого в модуле `board_manager` лежит удобная функция --- `activate_around`, её достаточно просто применить к каждой клетке поля(не границы)).
3. Пользователь инициализирует `PlayerManager` (Специальная структура для организации порядка ходов)
4. Пользователь использует эти структуры в своей реализации игры (Методы `make_move()` и `cancel_move()`)
5. ???
6. Profit!!!

# Ключевые контракты

Чтобы можно было предоставить функции `make_move()` и `cancel_move()` надо удовлетворить следующие контракты для поля и его клетки.

## Клетка

Клетка - единица поля. Имеет 3+1 ключевых состояния: пуста, содержит крестик, закрашена, является границей. Трейт клетки называется CellHandle неспроста. Это намёк на то, что вам не обязательно отдавать ссылку на то, что действительно храниться в поле. Это может быть более умный объект, способный, например, обновлять счётчик доступных ходов игрока при действиях с клеткой.

### Пустая клетка

Должна иметь следующие свойства:
1. Тип
2. Активность (Может ли игрок взаимодействовать с клеткой. Для каждого игрока, должна храниться своя, индивидуальная активность. Рекомендую использовать `bitfield` или что-то подобное)

### Крестик

1. Тип
2. Игрок (У каждого игрока свой цвет, а у цвета - игрок, поэтому слова игрок и цвет в контексте проекта - синонимы)
3. Активность (Естественно, для каждого игрока своя. Поскольку игрок не может взаимодействовать с крестиком своего цвета, ядро не читает активность крестика для своего же цвета, однако оно может пытаться его активировать (Так код получается проще, не судите строго). Если вы собираетесь использовать свободный бит для своих нужд, например для следующего пункта, то позаботьтесь о дополнительной проверке при активации крестика.)
4. "Важность" (`bool`. Используется для для уменьшения перепроверок.)

### Закрашенная клетка

1. Тип
2. Игрок
3. Жива или мертва (`bool`)
4. "Важность" (`bool`)

### Граница

1. Тип. Ну и всё на этом.

## Правила преобразования типов
Клетки должны преобразовываться из одного типа в другой по этим правилам:

1. Пустая клетка в крестик:
	- Тип меняется на крестик
 	- Игрок меняется на нового
	- Активность не изменяется за исключением активности игрока, поставившего крестик. Её можно изменить
2. Крестик в пустую клетку:
	- Тип меняется на пустую клетку
	- Активность не изменяется за исключением активности игрока, поставившего крестик. Она должна быть "активной"
3. Крестик в закрашенную клетку:
	- Тип меняется на закрашенную клетку
	- Игрок меняется на нового
	- Состояние --- "Живая"
4. Закрашенная клетка в крестик:
	- Тип меняется на крестик
	- Игрок меняется на старого
	- Активность --- нулевая
	
## Поле

Само игровое поле должно реализовывать следующие методы:

1. Получение клетки по индексу.
2. Получение всех индексов клеток вокруг.
3. Обход цепочки закрашенных клеток (И смежных с ними):
	- `revive(index, fn)` --- вызывается для оживления закрашенных клеток. Гарантируется, что под индексом будет лежать мёртвая закрашенная клетка. Передаваемую функцию надо применить ко всем клеткам обхода (В том числе и незакрашенные смежные клетки).
	- `search(index, fn) -> Option<Index>` --- вызывается для поиска крестика, активирующего цепочку крестиков. Если такой крестик найден, fn вернёт индекс нового крестика. Гарантируется, что под индексом(начальным) будет лежать живая закрашенная клетка.
	- `kill(index, fn)` --- вызывается для умерщвления закрашенных клеток. Вызывается тогда и только тогда когда `search` возвращает `None`. Гарантируется, что будет передан тот же индекс, что и `search`, а клетки не изменят своё состояние между вызовами этих двух методов.
	- `traverse(index, fn) -> Option<Index>` --- обобщённая функция обхода. Определите её --- автоматически определятся первые три. fn возвращает ControlFlow, на который нужно соответственно реагировать (Вернуть значение Break, либо None)


